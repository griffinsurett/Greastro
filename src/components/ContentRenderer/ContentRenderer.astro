---
// src/components/ContentRenderer/ContentRenderer.astro
/**
 * Content Renderer Component - Universal Content Section Renderer
 *
 * This is the main orchestrator component that:
 * 1. Accepts a Query object and executes it to fetch collection entries
 * 2. Extracts collection metadata from _meta.mdx files
 * 3. Prepares entries with resolved references and proper URLs
 * 4. Generates unique IDs for sections (with auto-incrementing for duplicates)
 * 5. Delegates rendering to specialized variant components
 * 
 * ID GENERATION:
 * - Single collection: {collection}-{url-slug} (e.g., "blog-home")
 * - Multi-collection: {coll1-coll2}-{url-slug} (e.g., "blog-portfolio-about")
 * - Duplicates: Appends -1, -2, etc. (e.g., "blog-home-1")
 * - Manual override: Pass `id` prop to skip auto-generation
 *
 * USAGE PATTERNS:
 * 
 * Single-collection (auto-populates title/description from _meta.mdx):
 *   <ContentRenderer query={query('blog').limit(5)} variant="BlogVariant" />
 *
 * Multi-collection (requires manual title/description):
 *   <ContentRenderer
 *     query={query(['blog', 'portfolio']).limit(10)}
 *     variant="ListVariant"
 *     title="Recent Updates"
 *     description="Latest content"
 *   />
 * 
 * Static content (no query):
 *   <ContentRenderer
 *     items={[...]}
 *     variant="GridVariant"
 *     title="Features"
 *   />
 * 
 * Manual ID override:
 *   <ContentRenderer
 *     query={query('services')}
 *     variant="CardVariant"
 *     id="featured-services"
 *   />
 */

import type { SectionProps } from "./ContentRenderer.types";
import { getVariantComponents } from "@/components/ContentRenderer/variants/utils/VariantUtils";
import { prepareCollectionEntries, prepareEntry } from "@/utils/collections";
import { getCollectionMeta } from "@/utils/collections";
import { shouldCollectionHavePage } from "@/utils/pages";
import { getQueryCollection } from "./utils/queryIntrospection";
import { generateIdFromAstro } from "./utils/variantId";

// ============================================================================
// SETUP: Load all available variant components
// ============================================================================
const variantComponents = await getVariantComponents();

// ============================================================================
// PROPS: Extract and organize component props
// ============================================================================
const {
  query: queryProp,              // Query object for fetching collection items
  variant = "GridVariant",       // Which variant to render (defaults to GridVariant)
  title: titleOverride,          // Manual title override
  description: descriptionOverride, // Manual description override
  id: manualId,                  // Manual ID override (skips auto-generation)
  ...restProps                   // All other props (passed to variant)
} = Astro.props as SectionProps;

// ============================================================================
// DATA PREPARATION: Build data object for variant component
// ============================================================================
let data: any;

if (queryProp) {
  // ──────────────────────────────────────────────────────────────────────────
  // QUERY MODE: Execute query and prepare items
  // ──────────────────────────────────────────────────────────────────────────
  
  // Execute the query to get entries
  const result = await queryProp.get();

  // Extract collection name(s) from query
  // Returns string for single collection, null for multi-collection
  const queryCollection = getQueryCollection(queryProp);

  if (queryCollection) {
    // ═══════════════════════════════════════════════════════════════════════
    // SINGLE COLLECTION MODE - Automatic metadata population
    // ═══════════════════════════════════════════════════════════════════════
    // When querying a single collection, we can automatically populate
    // title, description, and "View All" link from the collection's _meta.mdx
    
    // Load collection metadata from _meta.mdx
    const meta = getCollectionMeta(queryCollection);

    // Prepare all entries with:
    // - Resolved references (author → full author object)
    // - Proper URLs (/blog/post or /post based on rootPath)
    // - All data ready for rendering
    const preparedItems = await prepareCollectionEntries(
      result.entries,
      queryCollection,
      meta
    );

    // Check if we're currently ON the collection's index page
    // If so, we don't want to show title/description or "View All" link
    const currentPath = Astro.url.pathname;
    const collectionIndexPath = `/${queryCollection}`;
    const isOnCollectionPage =
      currentPath === collectionIndexPath ||
      currentPath === `${collectionIndexPath}/`;

    // Build data object with automatic metadata
    data = {
      items: preparedItems,
      
      // Use manual override if provided, otherwise use meta title
      // (but not on the collection page itself to avoid redundancy)
      title: titleOverride ?? (isOnCollectionPage ? undefined : meta.title),
      
      // Same logic for description
      description:
        descriptionOverride ??
        (isOnCollectionPage ? undefined : meta.description),
      
      // Only show "View All" link if:
      // 1. Collection has a page (hasPage: true in _meta.mdx)
      // 2. We're not already on the collection page
      collectionUrl:
        shouldCollectionHavePage(meta) && !isOnCollectionPage
          ? collectionIndexPath
          : undefined,
      
      // Collection title for "View All" button text
      collectionTitle:
        meta.title ||
        queryCollection.charAt(0).toUpperCase() + queryCollection.slice(1),
      
      // Spread any additional props (columns, gap, etc.)
      ...restProps,
    };
  } else {
    // ═══════════════════════════════════════════════════════════════════════
    // MULTI-COLLECTION MODE - Manual metadata required
    // ═══════════════════════════════════════════════════════════════════════
    // When querying multiple collections, we can't automatically determine
    // which _meta.mdx to use, so title/description must be provided manually
    
    // Prepare each entry using the same logic as single-collection
    // This ensures proper handling of:
    // - rootPath (items at /slug vs /collection/slug)
    // - hasPage (items without pages get no URL)
    // - Reference resolution (author references, etc.)
    const preparedItems = await Promise.all(
      result.entries.map(async (entry) => {
        const collection = entry.collection;
        const meta = getCollectionMeta(collection);

        // Use the same prepareEntry logic as single-collection
        return await prepareEntry(entry, collection, meta);
      })
    );

    // Build data object - requires manual title/description
    data = {
      items: preparedItems,
      title: titleOverride,
      description: descriptionOverride,
      // No collectionUrl or collectionTitle for multi-collection
      ...restProps,
    };

    // Warn developer if they forgot to provide title/description
    if (!titleOverride || !descriptionOverride) {
      console.warn(
        `[ContentRenderer] Multi-collection query used without title/description. ` +
          `Please provide these props manually when querying multiple collections.`
      );
    }
  }
} else {
  // ──────────────────────────────────────────────────────────────────────────
  // STATIC MODE: No query, using manually provided items
  // ──────────────────────────────────────────────────────────────────────────
  // Useful for hero sections, featured content, or any non-collection data
  data = restProps.items ? restProps : { items: [], ...restProps };
}

// ============================================================================
// ID GENERATION: Create unique section ID
// ============================================================================
// Automatically generates IDs based on:
// - Collection name(s) from query
// - Current page URL
// - Auto-incrementing counter for duplicates
//
// Examples:
// - First blog section on /: "blog-home"
// - Second blog section on /: "blog-home-1"
// - Multi-collection on /about: "blog-portfolio-about"
// - Manual override: Whatever you pass in `id` prop
const variantId = generateIdFromAstro(Astro, {
  query: queryProp,
  manualId,
});

// Add generated ID to data object (variants will use this)
data.id = variantId;

// ============================================================================
// VARIANT RENDERING: Get and render the appropriate variant component
// ============================================================================

// Get the variant component or throw error if not found
const VariantComponent = variantComponents[variant];
if (!VariantComponent) {
  const availableVariants = Object.keys(variantComponents).join(', ');
  throw new Error(
    `Variant "${variant}" not found. Available variants: ${availableVariants}`
  );
}
---

<!-- Render the selected variant with all prepared data -->
<VariantComponent {...data} />