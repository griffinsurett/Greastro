---
// src/components/docs/sidebar/Sidebar.astro
/**
 * Documentation Sidebar Navigation
 * Fixed sidebar with automatic active state detection
 */

import SidebarSection from "./SidebarSection.astro";

export interface Props {
  sections?: {
    title: string;
    items: {
      label: string;
      href: string;
    }[];
  }[];
}

const { sections = [] } = Astro.props;

// Default sections if none provided
const defaultSections = [
  {
    title: "Getting Started",
    items: [
      { label: "Overview", href: "#overview" },
      { label: "Installation", href: "#installation" },
    ],
  },
  {
    title: "Basic Queries",
    items: [
      { label: "Simple Queries", href: "#simple-queries" },
      { label: "Filtering", href: "#filtering" },
      { label: "Sorting", href: "#sorting" },
      { label: "Pagination", href: "#pagination" },
    ],
  },
  {
    title: "Advanced Features",
    items: [
      { label: "Multi-Collection", href: "#multi-collection" },
      { label: "Hierarchical Queries", href: "#hierarchical" },
      { label: "Relations", href: "#relations" },
      { label: "Statistics", href: "#statistics" },
    ],
  },
  {
    title: "Reference",
    items: [
      { label: "API Reference", href: "#api-reference" },
      { label: "Best Practices", href: "#best-practices" },
    ],
  },
];

const navSections = sections.length > 0 ? sections : defaultSections;
---

<aside class="docs-sidebar" data-docs-sidebar>
  <div class="p-6 pb-32">
    <!-- Logo/Brand -->
    <a href="/" class="flex items-center gap-3 mb-10 group">
      <div
        class="w-10 h-10 bg-gradient-to-br from-docs-accent to-docs-purple rounded-xl group-hover:scale-105 transition-transform"
      >
      </div>
      <span class="font-bold text-xl text-docs-text">Query Docs</span>
    </a>

    <!-- Navigation Sections -->
    <nav class="space-y-8">
      {
        navSections.map((section) => (
          <SidebarSection title={section.title} items={section.items} />
        ))
      }
    </nav>
  </div>
</aside>

<script>
  /**
   * Sidebar Active State Manager
   * - Highlights active link based on scroll position
   * - Updates on hash change
   * - Smooth transition between states
   */

  class SidebarActiveState {
    private links: NodeListOf<HTMLElement>;
    private sections: Map<string, Element>;
    private activeLink: HTMLElement | null = null;
    private observer: IntersectionObserver | null = null;

    constructor() {
      this.links = document.querySelectorAll("[data-sidebar-link]");
      this.sections = new Map();
      this.init();
    }

    init() {
      // Map all section IDs to their elements
      this.links.forEach((link) => {
        const target = link.getAttribute("data-target");
        if (target) {
          const section = document.getElementById(target);
          if (section) {
            this.sections.set(target, section);
          }
        }
      });

      // Set up intersection observer
      this.setupIntersectionObserver();

      // Handle hash changes
      this.handleHashChange();
      window.addEventListener("hashchange", () => this.handleHashChange());

      // Initial state based on current hash
      if (window.location.hash) {
        this.setActiveByHash(window.location.hash.slice(1));
      } else {
        // Default to first link if no hash
        if (this.links.length > 0) {
          this.setActive(this.links[0] as HTMLElement);
        }
      }
    }

    setupIntersectionObserver() {
      type MostVisibleEntry = {
        entry: IntersectionObserverEntry;
        ratio: number;
      };

      const options = {
        rootMargin: "-20% 0px -35% 0px",
        threshold: [0, 0.25, 0.5, 0.75, 1],
      };

      this.observer = new IntersectionObserver((entries) => {
        let mostVisible: MostVisibleEntry | null = null;

        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (!mostVisible || entry.intersectionRatio > mostVisible.ratio) {
              mostVisible = { entry, ratio: entry.intersectionRatio };
            }
          }
        });

        if (mostVisible) {
          const sectionId = (mostVisible as MostVisibleEntry).entry.target.id;
          this.setActiveByHash(sectionId);
        }
      }, options);

      this.sections.forEach((section) => {
        this.observer?.observe(section);
      });
    }

    handleHashChange() {
      const hash = window.location.hash.slice(1);
      if (hash) {
        this.setActiveByHash(hash);
      }
    }

    setActiveByHash(hash: string) {
      const link = Array.from(this.links).find(
        (l) => l.getAttribute("data-target") === hash
      ) as HTMLElement;

      if (link) {
        this.setActive(link);
      }
    }

    setActive(link: HTMLElement) {
      if (this.activeLink === link) return;

      // Remove active state from previous
      if (this.activeLink) {
        this.activeLink.classList.remove("docs-sidebar-link-active");
      }

      // Add active state to new
      link.classList.add("docs-sidebar-link-active");

      this.activeLink = link;

      // Scroll link into view if needed
      this.scrollLinkIntoView(link);
    }

    scrollLinkIntoView(link: HTMLElement) {
      const sidebar = document.querySelector("[data-docs-sidebar]");
      if (!sidebar) return;

      const linkRect = link.getBoundingClientRect();
      const sidebarRect = sidebar.getBoundingClientRect();

      if (
        linkRect.top < sidebarRect.top ||
        linkRect.bottom > sidebarRect.bottom
      ) {
        link.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }
    }
  }

  // Initialize on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      new SidebarActiveState();
    });
  } else {
    new SidebarActiveState();
  }
</script>
