---
// src/components/section/Section.astro
/**
 * Section Component - Universal Content Section Renderer
 * 
 * Designed for single-collection queries with automatic metadata.
 * For multi-collection queries, provide title/description manually.
 * 
 * Single-collection example (auto-populates title/description):
 *   <Section query={query('blog').limit(5)} variant="BlogVariant" />
 * 
 * Multi-collection example (requires manual props):
 *   <Section 
 *     query={query(['blog', 'portfolio']).limit(10)} 
 *     variant="ListVariant"
 *     title="Recent Updates"
 *     description="Latest content"
 *   />
 */

import type { SectionProps } from './Section.types';
import { getVariantComponents } from '@/components/section/variants/utils/VariantUtils';
import { prepareCollectionEntries, prepareEntry } from '@/utils/collections';
import { getCollectionMeta } from '@/utils/collections';
import { shouldCollectionHavePage } from '@/utils/pages';
import { getQueryCollection } from './utils/queryIntrospection';

// Load all available variant components
const variantComponents = await getVariantComponents();

const { 
  query: queryProp,
  variant = 'GridVariant',
  title: titleOverride,
  description: descriptionOverride,
  ...restProps
} = Astro.props as SectionProps;

let data: any;

if (queryProp) {
  // Execute the query
  const result = await queryProp.get();
  
  // Extract collection from query (null for multi-collection)
  const queryCollection = getQueryCollection(queryProp);
  
  if (queryCollection) {
    // ═══════════════════════════════════════════════════════════
    // SINGLE COLLECTION - Automatic metadata population
    // ═══════════════════════════════════════════════════════════
    const meta = getCollectionMeta(queryCollection);
    
    // Prepare items with full collection context
    const preparedItems = await prepareCollectionEntries(
      result.entries,
      queryCollection,
      meta
    );
    
    // Check if we're on the collection's index page
    const currentPath = Astro.url.pathname;
    const collectionIndexPath = `/${queryCollection}`;
    const isOnCollectionPage = currentPath === collectionIndexPath || 
                                currentPath === `${collectionIndexPath}/`;
    
    data = {
      items: preparedItems,
      // Use override title if provided, otherwise use meta title (but not on collection page itself)
      title: titleOverride ?? (isOnCollectionPage ? undefined : meta.title),
      description: descriptionOverride ?? (isOnCollectionPage ? undefined : meta.description),
      // Only show "View All" link if collection has a page and we're not already on it
      collectionUrl: shouldCollectionHavePage(meta) && !isOnCollectionPage ? collectionIndexPath : undefined,
      collectionTitle: meta.title || queryCollection.charAt(0).toUpperCase() + queryCollection.slice(1),
      ...restProps
    };
  } else {
    // ═══════════════════════════════════════════════════════════
    // MULTI-COLLECTION - Proper preparation with prepareEntry
    // ═══════════════════════════════════════════════════════════
    // Prepare each entry using the same logic as single-collection
    // This ensures proper handling of:
    // - rootPath (items at /slug vs /collection/slug)
    // - hasPage (items without pages get no URL)
    // - Reference resolution (author references, etc.)
    const preparedItems = await Promise.all(
      result.entries.map(async (entry) => {
        const collection = entry.collection;
        const meta = getCollectionMeta(collection);
        
        // Use the same prepareEntry logic as single-collection
        return await prepareEntry(entry, collection, meta);
      })
    );
    
    data = {
      items: preparedItems,
      title: titleOverride,
      description: descriptionOverride,
      // No collectionUrl or collectionTitle for multi-collection
      ...restProps
    };
    
    // Warn if title/description not provided for multi-collection
    if (!titleOverride || !descriptionOverride) {
      console.warn(
        `[Section] Multi-collection query used without title/description. ` +
        `Please provide these props manually when querying multiple collections.`
      );
    }
  }
} else {
  // ═══════════════════════════════════════════════════════════
  // STATIC MODE - No query, just items
  // ═══════════════════════════════════════════════════════════
  data = restProps.items ? restProps : { items: [], ...restProps };
}

// Get the variant component or throw error if not found
const VariantComponent = variantComponents[variant];
if (!VariantComponent) {
  throw new Error(`Variant "${variant}" not found`);
}
---
<VariantComponent {...data} />