---
// src/layouts/SEO.astro
import defaultOGImage from "@/assets/astro.svg";
import { siteData } from "@/content/siteData";
import type { ImageMetadata } from 'astro';
import { getEntry } from 'astro:content';

// Type definition for author data
type AuthorData = {
  data: {
    title?: string;
    name?: string;
    email?: string;
    social?: {
      website?: string;
      twitter?: string;
      github?: string;
      linkedin?: string;
    };
  };
} | null;

// Helper type for image data that could come from various sources
type ImageData = string | ImageMetadata | { 
  src: string | ImageMetadata; 
  alt?: string;
  format?: string;
  width?: number;
  height?: number;
};

export interface Props {
  // Primary content fields (from collection items or pages)
  title?: string;
  description?: string;
  featuredImage?: ImageData;
  author?: string | { collection: string; id: string } | any;
  publishDate?: Date | string;
  
  // Collection-level defaults
  collectionTitle?: string;
  collectionDescription?: string;
  collectionImage?: ImageData;
  
  // SEO-specific overrides (from seo field)
  seo?: {
    metaTitle?: string;
    metaDescription?: string;
    ogTitle?: string;
    ogDescription?: string;
    ogImage?: ImageData;
    ogType?: string;
    twitterTitle?: string;
    twitterDescription?: string;
    twitterImage?: ImageData;
    twitterCard?: string;
    canonicalUrl?: string;
    robots?: string;
    keywords?: string[];
  };
  
  // Direct props (for backwards compatibility)
  keywords?: string[];
  canonicalUrl?: string;
  robots?: string;
  siteName?: string;
  ogType?: string;
}

const {
  // Content fields
  title,
  description,
  featuredImage,
  author,
  publishDate,
  
  // Collection defaults
  collectionTitle,
  collectionDescription,
  collectionImage,
  
  // SEO overrides
  seo = {},
  
  // Direct props
  keywords,
  canonicalUrl,
  robots,
  siteName = siteData.title,
  ogType,
} = Astro.props;

// Helper function to extract image URL from various formats
const getImageUrl = (img: ImageData | undefined): string => {
  if (!img) return defaultOGImage.src;
  
  // If it's a string, return it
  if (typeof img === 'string') return img;
  
  // If it's an Astro ImageMetadata object (imported image)
  if ('src' in img && typeof img.src === 'string' && 'format' in img) {
    return img.src;
  }
  
  // If it's an object with src property
  if ('src' in img) {
    if (typeof img.src === 'string') return img.src;
    // If src is itself an ImageMetadata object
    if (typeof img.src === 'object' && 'src' in img.src) {
      return img.src.src;
    }
  }
  
  return defaultOGImage.src;
};

// Helper function to get alt text
const getImageAlt = (img: ImageData | undefined, fallback: string = ''): string => {
  if (!img) return fallback;
  if (typeof img === 'object' && 'alt' in img && typeof img.alt === 'string') {
    return img.alt;
  }
  return fallback;
};

// Resolve author data if it's a reference
let authorData: AuthorData = null;
let authorName = siteData.title; // Default author to site title

if (author) {
  if (typeof author === 'string') {
    // It's just an ID, try to get from authors collection
    try {
      const entry = await getEntry('authors', author);
      if (entry) {
        authorData = { data: entry.data };
        authorName = entry.data.title || author;
      } else {
        authorName = author;
      }
    } catch (e) {
      // Not a valid author reference, use as string
      authorName = author;
    }
  } else if (author && typeof author === 'object') {
    if ('collection' in author && author.collection === 'authors') {
      // It's a reference object
      const entry = await getEntry('authors', author.id);
      if (entry) {
        authorData = { data: entry.data };
        authorName = entry.data.title || author.id;
      }
    } else if ('data' in author) {
      // It's already resolved
      authorData = author as AuthorData;
      authorName = author.data?.title || author.data?.name || siteData.title;
    } else if ('title' in author || 'name' in author) {
      // It's author data
      const authorObj = author as any;
      authorName = authorObj.title || authorObj.name;
      authorData = { data: authorObj };
    }
  }
}

// Build hierarchical defaults
// Priority: SEO overrides > Direct props > Page data > Collection data > Site defaults

// Determine base values with fallback hierarchy
const baseTitle = title || collectionTitle || "Page";
const baseDescription = description || collectionDescription || siteData.description;
const baseImageUrl = getImageUrl(featuredImage || collectionImage);
const baseImageAlt = getImageAlt(featuredImage || collectionImage, baseTitle);

// Meta tags (HTML head)
const finalMetaTitle = seo.metaTitle || `${baseTitle} | ${siteData.title}`;
const finalMetaDescription = seo.metaDescription || baseDescription;

// Open Graph
const finalOgTitle = seo.ogTitle || seo.metaTitle || baseTitle;
const finalOgDescription = seo.ogDescription || seo.metaDescription || baseDescription;
const finalOgImageUrl = getImageUrl(seo.ogImage) || baseImageUrl;
const finalOgImageAlt = getImageAlt(seo.ogImage, finalOgTitle);
const finalOgType = seo.ogType || ogType || "website";

// Twitter Card
const finalTwitterTitle = seo.twitterTitle || seo.ogTitle || finalOgTitle;
const finalTwitterDescription = seo.twitterDescription || seo.ogDescription || finalOgDescription;
const finalTwitterImageUrl = getImageUrl(seo.twitterImage || seo.ogImage) || finalOgImageUrl;
const finalTwitterImageAlt = getImageAlt(seo.twitterImage || seo.ogImage, finalTwitterTitle);
const finalTwitterCard = seo.twitterCard || "summary_large_image";

// Other SEO fields
const finalKeywords = seo.keywords || keywords;
const finalCanonicalUrl = seo.canonicalUrl || canonicalUrl || `${siteData.url}${Astro.url.pathname}`;

// Publisher info - always use site data
const publisherName = siteData.legalName || siteData.title;

// Robots directives - simplified with direct robots string
const effectiveRobots = seo?.robots || robots || "index, follow";

// Ensure image URLs are absolute
const makeAbsolute = (imageSrc: string): string => {
  if (imageSrc.startsWith('http')) return imageSrc;
  if (imageSrc.startsWith('/')) return `${siteData.url}${imageSrc}`;
  return `${siteData.url}/${imageSrc}`;
};

const absoluteOgImage = makeAbsolute(finalOgImageUrl);
const absoluteTwitterImage = makeAbsolute(finalTwitterImageUrl);

// Determine schema type based on content
const schemaType = finalOgType === "website" || !publishDate ? "WebSite" : "Article";

// Build structured data
const structuredData: any = {
  "@context": "https://schema.org",
  "@type": schemaType,
  "name": finalOgTitle,
  "headline": finalOgTitle,
  "description": finalOgDescription,
  "image": absoluteOgImage,
  "url": finalCanonicalUrl,
  "publisher": {
    "@type": "Organization",
    "name": publisherName,
    "url": siteData.url,
    "logo": {
      "@type": "ImageObject",
      "url": makeAbsolute(defaultOGImage.src),
      "width": 60,
      "height": 60
    }
  },
  "author": {
    "@type": authorData ? "Person" : "Organization",
    "name": authorName,
    ...(authorData?.data?.email && { "email": authorData.data.email }),
    ...(authorData?.data?.social?.website && { "url": authorData.data.social.website }),
  },
  ...(publishDate && {
    "datePublished": new Date(publishDate).toISOString(),
    "dateModified": new Date(publishDate).toISOString(),
  }),
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": finalCanonicalUrl
  }
};

// Add default keywords if none provided
const defaultKeywords = ["astro", "static site generator", "web development", "typescript"];
const allKeywords = finalKeywords && finalKeywords.length > 0 ? finalKeywords : defaultKeywords;

if (import.meta.env.DEV) {
  console.log("SEO Data:", {
    seoRobots: seo?.robots,
    authorName,
    publisherName,
    schemaType,
    robots: effectiveRobots,
    structuredData,
  });
}
---

<!-- Primary Meta Tags -->
<title>{finalMetaTitle}</title>
<meta name="title" content={finalMetaTitle} />
<meta name="description" content={finalMetaDescription} />
<meta name="author" content={authorName} />
<meta name="publisher" content={publisherName} />
<meta name="keywords" content={allKeywords.join(", ")} />

<link rel="canonical" href={finalCanonicalUrl} />
<meta name="robots" content={effectiveRobots} />

<!-- Open Graph / Facebook -->
<meta property="og:title" content={finalOgTitle} />
<meta property="og:description" content={finalOgDescription} />
<meta property="og:image" content={absoluteOgImage} />
{finalOgImageAlt && <meta property="og:image:alt" content={finalOgImageAlt} />}
<meta property="og:type" content={finalOgType} />
<meta property="og:url" content={finalCanonicalUrl} />
<meta property="og:site_name" content={siteName} />
{publishDate && <meta property="article:published_time" content={new Date(publishDate).toISOString()} />}
<meta property="article:author" content={authorName} />
<meta property="article:publisher" content={publisherName} />

<!-- Twitter -->
<meta name="twitter:card" content={finalTwitterCard} />
<meta name="twitter:title" content={finalTwitterTitle} />
<meta name="twitter:description" content={finalTwitterDescription} />
<meta name="twitter:image" content={absoluteTwitterImage} />
{finalTwitterImageAlt && <meta name="twitter:image:alt" content={finalTwitterImageAlt} />}
<meta property="twitter:url" content={finalCanonicalUrl} />
<meta name="twitter:creator" content={authorName} />

<!-- JSON-LD Structured Data -->
<script type="application/ld+json" set:html={JSON.stringify(structuredData)} />

<!-- Structured Data Slot -->
<slot name="structuredData" />