---
// src/layouts/SEO.astro
import defaultOGImage from "@/assets/astro.svg";
import { siteData } from "@/content/siteData";
import type { ImageMetadata } from 'astro';
import { getEntry } from 'astro:content';

// Helper type for image data that could come from various sources
type ImageData = string | ImageMetadata | { 
  src: string | ImageMetadata; 
  alt?: string;
  format?: string;
  width?: number;
  height?: number;
};

export interface Props {
  // Primary content fields (from collection items or pages)
  title?: string;
  description?: string;
  featuredImage?: ImageData;
  author?: string | { collection: string; id: string } | any;
  publishDate?: Date | string;
  
  // Collection-level defaults
  collectionTitle?: string;
  collectionDescription?: string;
  collectionImage?: ImageData;
  
  // SEO-specific overrides (from seo field)
  seo?: {
    metaTitle?: string;
    metaDescription?: string;
    ogTitle?: string;
    ogDescription?: string;
    ogImage?: ImageData;
    ogType?: string;
    twitterTitle?: string;
    twitterDescription?: string;
    twitterImage?: ImageData;
    twitterCard?: string;
    canonicalUrl?: string;
    noindex?: boolean;
    nofollow?: boolean;
    keywords?: string[];
  };
  
  // Direct props (for backwards compatibility)
  keywords?: string[];
  canonicalUrl?: string;
  robots?: string;
  siteName?: string;
  ogType?: string;
  noindex?: boolean;
  nofollow?: boolean;
}

const {
  // Content fields
  title,
  description,
  featuredImage,
  author,
  publishDate,
  
  // Collection defaults
  collectionTitle,
  collectionDescription,
  collectionImage,
  
  // SEO overrides
  seo = {},
  
  // Direct props
  keywords,
  canonicalUrl,
  robots,
  siteName = siteData.title,
  ogType,
  noindex,
  nofollow,
} = Astro.props;

// Helper function to extract image URL from various formats
const getImageUrl = (img: ImageData | undefined): string => {
  if (!img) return defaultOGImage.src;
  
  // If it's a string, return it
  if (typeof img === 'string') return img;
  
  // If it's an Astro ImageMetadata object (imported image)
  if ('src' in img && typeof img.src === 'string' && 'format' in img) {
    return img.src;
  }
  
  // If it's an object with src property
  if ('src' in img) {
    if (typeof img.src === 'string') return img.src;
    // If src is itself an ImageMetadata object
    if (typeof img.src === 'object' && 'src' in img.src) {
      return img.src.src;
    }
  }
  
  return defaultOGImage.src;
};

// Helper function to get alt text
const getImageAlt = (img: ImageData | undefined, fallback: string = ''): string => {
  if (!img) return fallback;
  if (typeof img === 'object' && 'alt' in img && typeof img.alt === 'string') {
    return img.alt;
  }
  return fallback;
};

// Resolve author data if it's a reference
let authorData = null;
if (author) {
  if (typeof author === 'string') {
    // It's just an ID, try to get from authors collection
    try {
      authorData = await getEntry('authors', author);
    } catch (e) {
      // Not a valid author reference, use as string
      authorData = { data: { title: author } };
    }
  } else if (author && typeof author === 'object') {
    if ('collection' in author && author.collection === 'authors') {
      // It's a reference object
      authorData = await getEntry('authors', author.id);
    } else if ('data' in author) {
      // It's already resolved
      authorData = author;
    } else if ('title' in author || 'name' in author) {
      // It's author data
      authorData = { data: author };
    }
  }
}

// Build hierarchical defaults
// Priority: SEO overrides > Direct props > Page data > Collection data > Site defaults

// Determine base values with fallback hierarchy
const baseTitle = title || collectionTitle || "Page";
const baseDescription = description || collectionDescription || siteData.description;
const baseImageUrl = getImageUrl(featuredImage || collectionImage);
const baseImageAlt = getImageAlt(featuredImage || collectionImage, baseTitle);

// Meta tags (HTML head)
const finalMetaTitle = seo.metaTitle || `${baseTitle} | ${siteData.title}`;
const finalMetaDescription = seo.metaDescription || baseDescription;

// Open Graph
const finalOgTitle = seo.ogTitle || seo.metaTitle || baseTitle;
const finalOgDescription = seo.ogDescription || seo.metaDescription || baseDescription;
const finalOgImageUrl = getImageUrl(seo.ogImage) || baseImageUrl;
const finalOgImageAlt = getImageAlt(seo.ogImage, finalOgTitle);
const finalOgType = seo.ogType || ogType || "website";

// Twitter Card
const finalTwitterTitle = seo.twitterTitle || seo.ogTitle || finalOgTitle;
const finalTwitterDescription = seo.twitterDescription || seo.ogDescription || finalOgDescription;
const finalTwitterImageUrl = getImageUrl(seo.twitterImage || seo.ogImage) || finalOgImageUrl;
const finalTwitterImageAlt = getImageAlt(seo.twitterImage || seo.ogImage, finalTwitterTitle);
const finalTwitterCard = seo.twitterCard || "summary_large_image";

// Other SEO fields
const finalKeywords = seo.keywords || keywords;
const finalCanonicalUrl = seo.canonicalUrl || canonicalUrl || `${siteData.url}${Astro.url.pathname}`;

// Robots directives
const shouldNoindex = seo.noindex || noindex || false;
const shouldNofollow = seo.nofollow || nofollow || false;
const effectiveRobots = robots || 
  (shouldNoindex && shouldNofollow ? "noindex, nofollow" :
   shouldNoindex ? "noindex, follow" :
   shouldNofollow ? "index, nofollow" : "index, follow");

// Ensure image URLs are absolute
const makeAbsolute = (imageSrc: string): string => {
  if (imageSrc.startsWith('http')) return imageSrc;
  if (imageSrc.startsWith('/')) return `${siteData.url}${imageSrc}`;
  return `${siteData.url}/${imageSrc}`;
};

const absoluteOgImage = makeAbsolute(finalOgImageUrl);
const absoluteTwitterImage = makeAbsolute(finalTwitterImageUrl);

// Determine schema type based on content
const schemaType = finalOgType === "website" ? "WebSite" : "Article";

// Build structured data
const structuredData = {
  "@context": "https://schema.org",
  "@type": schemaType,
  "headline": finalOgTitle,
  "description": finalOgDescription,
  "image": absoluteOgImage,
  "url": finalCanonicalUrl,
  "publisher": {
    "@type": "Organization",
    "name": siteData.legalName || siteData.title || "Greastro",
    "url": siteData.url,
    "logo": {
      "@type": "ImageObject",
      "url": makeAbsolute(defaultOGImage.src),
      "width": 60,
      "height": 60
    }
  },
  ...(publishDate && {
    "datePublished": new Date(publishDate).toISOString(),
    "dateModified": new Date(publishDate).toISOString(),
  }),
  ...(authorData && {
    "author": {
      "@type": "Person",
      "name": authorData.data.title || authorData.data.name || "Unknown Author",
      ...(authorData.data.email && { "email": authorData.data.email }),
      ...(authorData.data.social?.website && { "url": authorData.data.social.website }),
    }
  }),
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": finalCanonicalUrl
  }
};

if (import.meta.env.DEV) {
  console.log("SEO Hierarchy:", {
    input: { title, description, featuredImage, author, collectionTitle, collectionDescription, collectionImage, seo },
    output: {
      finalMetaTitle,
      finalMetaDescription,
      finalOgTitle,
      finalOgDescription,
      absoluteOgImage,
      finalTwitterTitle,
      finalTwitterDescription,
      absoluteTwitterImage,
      authorData,
      structuredData,
    }
  });
}
---

<!-- Primary Meta Tags -->
<title>{finalMetaTitle}</title>
<meta name="title" content={finalMetaTitle} />
<meta name="description" content={finalMetaDescription} />
{authorData && <meta name="author" content={authorData.data.title || authorData.data.name} />}
<meta name="publisher" content={siteData.legalName || siteData.title} />

<link rel="canonical" href={finalCanonicalUrl} />
<meta name="robots" content={effectiveRobots} />

{
  finalKeywords && Array.isArray(finalKeywords) && finalKeywords.length > 0 && (
    <meta name="keywords" content={finalKeywords.join(", ")} />
  )
}

<!-- Open Graph / Facebook -->
<meta property="og:title" content={finalOgTitle} />
<meta property="og:description" content={finalOgDescription} />
<meta property="og:image" content={absoluteOgImage} />
{finalOgImageAlt && <meta property="og:image:alt" content={finalOgImageAlt} />}
<meta property="og:type" content={finalOgType} />
<meta property="og:url" content={finalCanonicalUrl} />
<meta property="og:site_name" content={siteName} />
{publishDate && <meta property="article:published_time" content={new Date(publishDate).toISOString()} />}
{authorData && <meta property="article:author" content={authorData.data.title || authorData.data.name} />}
<meta property="article:publisher" content={siteData.legalName || siteData.title} />

<!-- Twitter -->
<meta name="twitter:card" content={finalTwitterCard} />
<meta name="twitter:title" content={finalTwitterTitle} />
<meta name="twitter:description" content={finalTwitterDescription} />
<meta name="twitter:image" content={absoluteTwitterImage} />
{finalTwitterImageAlt && <meta name="twitter:image:alt" content={finalTwitterImageAlt} />}
<meta property="twitter:url" content={finalCanonicalUrl} />

<!-- JSON-LD Structured Data -->
<script type="application/ld+json" set:html={JSON.stringify(structuredData)} />

<!-- Structured Data Slot -->
<slot name="structuredData" />