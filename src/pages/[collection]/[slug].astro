---
// src/pages/[collection]/[slug].astro
import { getCollection } from "astro:content";
import type { CollectionKey } from "astro:content";
import BaseLayout from "@/layouts/BaseLayout.astro";
import { collections } from "@/content/config";
import { getCollectionMeta } from "@/utils/fetchMeta";
import { getItemKey } from "@/utils/getItemKey";
import {
  shouldItemHavePage,
  shouldProcessCollectionItems,
} from "@/utils/hasPageUtils";

export async function getStaticPaths() {
  const names = Object.keys(collections) as CollectionKey[];
  const paths: Array<{
    params: { collection: string; slug: string };
    props: any;
  }> = [];

  for (const coll of names) {
    // Check if this collection needs processing
    const shouldProcess = await shouldProcessCollectionItems(coll);
    if (!shouldProcess) continue;

    const meta = getCollectionMeta(coll);
    const entries = await getCollection(coll);

    entries
      .filter((entry) => shouldItemHavePage(entry, meta))
      .forEach((entry) => {
        paths.push({
          params: {
            collection: coll,
            slug: getItemKey(entry),
          },
          props: { 
            entry,
            collectionMeta: meta,
            collectionName: coll
          },
        });
      });
  }

  return paths;
}

const { entry, collectionMeta, collectionName } = Astro.props;
const { data } = entry;

// Check if this entry can be rendered (MDX/MD files have render, JSON files don't)
let Content = null;
let hasContent = false;

if (typeof entry.render === "function") {
  const rendered = await entry.render();
  Content = rendered.Content;
  // Check if there's actual content in the body (for MDX/MD files)
  hasContent = entry.body && entry.body.trim().length > 0;
}

// Build SEO object from flat fields
const seoData = {
  metaTitle: data.metaTitle,
  metaDescription: data.metaDescription,
  ogTitle: data.ogTitle,
  ogDescription: data.ogDescription,
  ogImage: data.ogImage,
  ogType: data.ogType,
  twitterTitle: data.twitterTitle,
  twitterDescription: data.twitterDescription,
  twitterImage: data.twitterImage,
  twitterCard: data.twitterCard,
  robots: data.robots,
  canonicalUrl: data.canonicalUrl,
  keywords: data.keywords,
};

// Prepare SEO props with hierarchical data
const seoProps = {
  // Item-level data
  title: data.title,
  description: data.description,
  featuredImage: data.featuredImage,
  author: data.author,
  publishDate: data.publishDate,
  
  // Collection-level defaults
  collectionTitle: collectionMeta.title,
  collectionDescription: collectionMeta.description,
  collectionImage: collectionMeta.featuredImage,
  
  // SEO data from flat fields
  seo: seoData,
  
  // Direct fields for backwards compatibility
  robots: data.robots,
  keywords: data.keywords,
  canonicalUrl: data.canonicalUrl,
};
---
<BaseLayout {...seoProps}>
  <main class="container mx-auto px-4 py-8">
    {
      hasContent && Content ? (
        <article class="prose lg:prose-xl mx-auto">
          <Content />
        </article>
      ) : (
          <div>
        <h1>{data.title}</h1>
        {data.description && <p>{data.description}</p>}
      </div>
      )
    }
  </main>
</BaseLayout>